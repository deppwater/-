# 最大值与最小值的差小于等于num的子数组数量
# 给定数组arr和整数num 返回共有多少个数组满足如下情况：
# max(arr[i...j]) - min(arr[i...j]) <= num
# 要求：
# 如果数组长度为N 时间复杂度为O(N)


"""
思路：
长度为N的数组总共的子数组数量为(子数组为连续的)：
N + (N - 1) + (N - 2) + ... + 1
即数量级为N^2的子数组
"""


# 常规方法：
# 时间复杂度：O(N^3)
def getCount(arr, num):
    length = len(arr)
    count = 0
    for i in range(length):
        for j in range(i, length):
            if max(arr[i:j]) - min(arr[i:j]) <= num:
                count += 1
    return count


"""
O(N)解法思路：
结论1：如果从L~R段的数组是符合要求的 那么该段中任意一个子数组都是达标的
结论2：如果从L-R段的数组不符合要求 那么该段向左或者向右扩(包含此段在内)都是不达标的
思路：
先让窗口的L和R停留在0位置的左侧 R开始向右扩 如果窗口内符合要求则一直扩 直到到达X位置时不符合要求停止
根据结论1 那么此时以0位置为开头达标的数组个数为x+1个 即：0~0,0~1，0~2,0~3...0~x 
根据结论2 0开头的数组已经找全
然后L向右移动一格 即窗口缩小一个位置 R继续试着向右移动
重复上面的步骤
"""

